{"version":3,"sources":["../../src/CacheManager.js"],"names":["_","BASE_DIR","FileSystem","cacheDirectory","CacheEntry","uri","options","getCacheEntry","path","exists","tmpPath","createDownloadResumable","downloadAsync","result","status","undefined","moveAsync","from","to","CacheManager","entries","deleteAsync","idempotent","makeDirectoryAsync","getInfoAsync","size","filename","ext","console","log","substring","lastIndexOf","indexOf","length","e","error","uniqueId","info"],"mappings":"ioBACA,8B,GAAYA,E,kCACZ,0BACA,mC,qfAOA,GAAMC,UAAcC,iBAAWC,cAAzB,oBAAN,C,GAEaC,W,SAAAA,U,YAMT,oBAAYC,GAAZ,CAAyBC,OAAzB,CAAmD,kCAC/C,KAAKD,GAAL,CAAWA,GAAX,CACA,KAAKC,OAAL,CAAeA,OAAf,CACH,C,iOAGUD,G,CAAgB,I,CAAhBA,G,CAAKC,O,CAAW,I,CAAXA,O,iDAC0BC,cAAcF,GAAd,C,4BAA/BG,I,MAAAA,I,CAAMC,M,MAAAA,M,CAAQC,O,MAAAA,O,KACjBD,M,yDACOD,I,0DAEUN,iBAAWS,uBAAX,CAAmCN,GAAnC,CAAwCK,OAAxC,CAAiDJ,OAAjD,EAA0DM,aAA1D,E,UAAfC,M,oBAEFA,QAAUA,OAAOC,MAAP,GAAkB,G,2DACrBC,S,2DAELb,iBAAWc,SAAX,CAAqB,CAAEC,KAAMP,OAAR,CAAiBQ,GAAIV,IAArB,CAArB,C,0CACCA,I,wFAIMW,a,qJAINd,G,CAAaC,O,CAAsC,CAC1D,GAAI,CAACa,aAAaC,OAAb,CAAqBf,GAArB,CAAL,CAAgC,CAC5Bc,aAAaC,OAAb,CAAqBf,GAArB,EAA4B,GAAID,WAAJ,CAAeC,GAAf,CAAoBC,OAApB,CAA5B,CACH,CACD,MAAOa,cAAaC,OAAb,CAAqBf,GAArB,CAAP,CACH,C,uNAGSH,iBAAWmB,WAAX,CAAuBpB,QAAvB,CAAiC,CAAEqB,WAAY,IAAd,CAAjC,C,0DACApB,iBAAWqB,kBAAX,CAA8BtB,QAA9B,C,uSAGeC,iBAAWsB,YAAX,CAAwBvB,QAAxB,CAAkC,CAACwB,KAAM,IAAP,CAAlC,C,8BAAdA,I,OAAAA,I,kCACAA,I,+FAfJL,O,CAAyC,E,wBAF/BD,Y,CAqBrB,GAAMZ,eAAgB,QAAhBA,cAAgB,CAAOF,GAAP,mLACdqB,QADc,QAEdC,GAFc,0EAKWzB,iBAAWsB,YAAX,CAAwBvB,QAAxB,CALX,8BAKNQ,OALM,OAKNA,MALM,IAMTA,OANS,6EAOJP,iBAAWqB,kBAAX,CAA8BtB,QAA9B,CAPI,+FAUd2B,QAAQC,GAAR,eAVc,QAalB,GAAI,CACAH,SAAWrB,IAAIyB,SAAJ,CAAczB,IAAI0B,WAAJ,CAAgB,GAAhB,CAAd,CAAoC1B,IAAI2B,OAAJ,CAAY,GAAZ,IAAqB,CAAC,CAAtB,CAA0B3B,IAAI4B,MAA9B,CAAuC5B,IAAI2B,OAAJ,CAAY,GAAZ,CAA3E,CAAX,CACAL,IAAMD,SAASM,OAAT,CAAiB,GAAjB,IAA0B,CAAC,CAA3B,CAA+B,MAA/B,CAAwCN,SAASI,SAAT,CAAmBJ,SAASK,WAAT,CAAqB,GAArB,CAAnB,CAA9C,CACH,CAAC,MAAOG,CAAP,CAAU,CACRN,QAAQO,KAAR,CAAcD,CAAd,EACH,CAEK1B,IApBY,IAoBFP,QApBE,CAoBS,kBAAKI,GAAL,CApBT,CAoBqBsB,GApBrB,CAqBZjB,OArBY,IAqBCT,QArBD,CAqBY,kBAAKI,GAAL,CArBZ,KAqByBL,EAAEoC,QAAF,EArBzB,CAqBwCT,GArBxC,mDAuBCzB,iBAAWsB,YAAX,CAAwBhB,IAAxB,CAvBD,UAuBZ6B,IAvBY,gBAwBV5B,MAxBU,CAwBC4B,IAxBD,CAwBV5B,MAxBU,kCAyBX,CAAEA,aAAF,CAAUD,SAAV,CAAgBE,eAAhB,CAzBW,sEAAtB","file":"CacheManager.js","sourcesContent":["// @flow\nimport * as _ from \"lodash\";\nimport {FileSystem} from \"expo\";\nimport SHA1 from \"crypto-js/sha1\";\n\nexport type DownloadOptions = {\n  md5?: boolean,\n  headers?: { [string]: string }\n};\n\nconst BASE_DIR = `${FileSystem.cacheDirectory}expo-image-cache/`;\n\nexport class CacheEntry {\n\n    uri: string;\n    options: DownloadOptions;\n    path: string;\n\n    constructor(uri: string, options: DownloadOptions) {\n        this.uri = uri;\n        this.options = options;\n    }\n\n    async getPath(): Promise<?string> {\n        const {uri, options} = this;\n        const {path, exists, tmpPath} = await getCacheEntry(uri);\n        if (exists) {\n            return path;\n        }\n        const result = await FileSystem.createDownloadResumable(uri, tmpPath, options).downloadAsync();\n        // If the image download failed, we don't cache anything\n        if (result && result.status !== 200) {\n            return undefined;\n        }\n        await FileSystem.moveAsync({ from: tmpPath, to: path });\n        return path;\n    }\n}\n\nexport default class CacheManager {\n\n    static entries: { [uri: string]: CacheEntry } = {};\n\n    static get(uri: string, options: DownloadOptions): CacheEntry {\n        if (!CacheManager.entries[uri]) {\n            CacheManager.entries[uri] = new CacheEntry(uri, options);\n        }\n        return CacheManager.entries[uri];\n    }\n\n    static async clearCache(): Promise<void> {\n        await FileSystem.deleteAsync(BASE_DIR, { idempotent: true });\n        await FileSystem.makeDirectoryAsync(BASE_DIR);\n    }\n    static async getCacheSize(): Promise<number> {\n        const {size} = await FileSystem.getInfoAsync(BASE_DIR, {size: true});\n        return size;\n    }\n}\n\nconst getCacheEntry = async (uri: string): Promise<{ exists: boolean, path: string, tmpPath: string }> => {\n    let filename;\n    let ext;\n\n    try {\n        const { exists } = await FileSystem.getInfoAsync(BASE_DIR);\n        if (!exists) {\n            await FileSystem.makeDirectoryAsync(BASE_DIR);\n        }\n    } catch (e) {\n        console.log(e);\n    }\n\n    try {\n        filename = uri.substring(uri.lastIndexOf(\"/\"), uri.indexOf(\"?\") === -1 ? uri.length : uri.indexOf(\"?\"));\n        ext = filename.indexOf(\".\") === -1 ? \".jpg\" : filename.substring(filename.lastIndexOf(\".\"));\n    } catch (e) {\n        console.error(e);\n    }\n\n    const path = `${BASE_DIR}${SHA1(uri)}${ext}`;\n    const tmpPath = `${BASE_DIR}${SHA1(uri)}-${_.uniqueId()}${ext}`;\n\n    const info = await FileSystem.getInfoAsync(path);\n    const { exists } = info;\n    return { exists, path, tmpPath };\n};\n"]}