{"version":3,"sources":["../../src/CacheManager.js"],"names":["_","FileSystem","BASE_DIR","cacheDirectory","CacheEntry","uri","options","getCacheEntry","path","exists","tmpPath","createDownloadResumable","downloadAsync","result","status","code","console","log","moveAsync","from","to","CacheManager","entries","deleteAsync","idempotent","makeDirectoryAsync","getInfoAsync","size","filename","ext","substring","lastIndexOf","indexOf","length","uniqueId","info"],"mappings":"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","file":"CacheManager.js","sourcesContent":["// eslint-disable no-console\n\n// @flow\nimport * as _ from 'lodash';\nimport * as FileSystem from 'expo-file-system';\nimport SHA1 from 'crypto-js/sha1';\n\nexport type DownloadOptions = {\n  md5?: boolean,\n  headers?: { [string]: string }\n};\n\nconst BASE_DIR = `${FileSystem.cacheDirectory}expo-image-cache/`;\n\nexport class CacheEntry {\n    uri: string;\n    options: DownloadOptions;\n    path: string;\n\n    constructor(uri: string, options: DownloadOptions) {\n        this.uri = uri;\n        this.options = options;\n    }\n\n    async getPath(): Promise<?string> {\n        const {uri, options} = this;\n\n        if (!uri) {\n            return null;\n        }\n\n        const { path, exists, tmpPath } = await getCacheEntry(uri);\n        if (exists) {\n            return path;\n        }\n\n        try {\n            const result = await FileSystem.createDownloadResumable(uri, tmpPath, options).downloadAsync();\n            // If the image download failed, we don't cache anything\n            if (result && result.status !== 200) {\n                return null;\n            }\n        } catch (e) {\n            if (e.code === 'ENOENT') {\n                return null;\n            }\n\n            console.log(e);\n        }\n\n        await FileSystem.moveAsync({ from: tmpPath, to: path });\n        return path;\n    }\n}\n\nexport default class CacheManager {\n    static entries: { [uri: string]: CacheEntry } = {};\n\n    static get(uri: string, options: DownloadOptions): CacheEntry {\n        if (!CacheManager.entries[uri]) {\n            CacheManager.entries[uri] = new CacheEntry(uri, options);\n        }\n        return CacheManager.entries[uri];\n    }\n\n    static async clearCache(): Promise<void> {\n        await FileSystem.deleteAsync(BASE_DIR, { idempotent: true });\n        await FileSystem.makeDirectoryAsync(BASE_DIR);\n    }\n\n    static async getCacheSize(): Promise<number> {\n        const {size} = await FileSystem.getInfoAsync(BASE_DIR, {size: true});\n        return size;\n    }\n}\n\nconst getCacheEntry = async (uri: string): Promise<{ exists: boolean, path: string, tmpPath: string }> => {\n    let filename;\n    let ext;\n\n    try {\n        const { exists } = await FileSystem.getInfoAsync(BASE_DIR);\n        if (!exists) {\n            await FileSystem.makeDirectoryAsync(BASE_DIR);\n        }\n    } catch (e) {\n        console.log(e);\n    }\n\n    try {\n        if (!uri) {\n            return { exists: false };\n        }\n\n        filename = uri.substring(uri.lastIndexOf('/'), uri.indexOf('?') === -1 ? uri.length : uri.indexOf('?'));\n        ext = filename.indexOf('.') === -1 ? '.jpg' : filename.substring(filename.lastIndexOf('.'));\n    } catch (e) {\n        console.log(e);\n    }\n\n    const path = `${BASE_DIR}${SHA1(uri)}${ext}`;\n    const tmpPath = `${BASE_DIR}${SHA1(uri)}-${_.uniqueId()}${ext}`;\n\n    try {\n        const info = await FileSystem.getInfoAsync(path);\n        const { exists } = info;\n        return { exists, path, tmpPath };\n    } catch (e) {\n        if (e.code !== 'ENOENT') {\n            console.log(e);\n        }\n\n        return { exists: false };\n    }\n};\n"]}